# Módulo 1. Conceptos de debugging y fuzzing
## Partes de la memoria
- **Buffer:** espacio de memoria que se reserva para guardar datos y manejar los mismos
- **Stack**: es donde se guardan las variables locales de una función que sólo se necesitan durante la ejecución de la función
- **Heap**: se usa para reservar memoria dinámica, cuya vida útil no se sabe de antemano, pero se espera que dure un tiempo. Si no sabemos su tamaño, se deberá calcular y reservar en el heap. También se usa para objetos que varían en tamaño, porque no sabemos en tiempo de compilación cuánto van a durar o abarcar.

## Definiciones
- **Binary diffing (o Program diffing)**: técnica de ingeniería inversa en la que se comparan 2 archivos a nivel binario en busca de diferencias o semejanzas en el código (se examina un archivo para ver qué ha cambiado con respecto al otro). Este tipo de técnica es útil para algunas tareas, como descubrir las nuevas funciones o mejoras que ha recibido un software o verificar si un nuevo parche es compatible con nuestro sistema para evitar "romperlo" en la implementación. Sin embargo, la característica más interesante es encontrar las vulnerabilidades que fueron parcheadas, comparando el archivo vulnerable original con el parcheado. Los **tools** más usados son: **DarumGrim**, **Zynamics Bindiff** o **Diaphora**.
- En una arquitectura de 32 bits el número más grande que se puede almacenar en un registro es de 32 bits (y en uno de 64 64 bits)
- **Registros de propósito general de 32 bits**: eax, ebx, ecx, edx, esi y edi
![[Pasted image 20230522155344.png]]
- **Formato little endian**: formato en que un ordenador almacena datos en las celdas de memoria. Se interpreta del revés:
![[Pasted image 20230522155635.png]]
![[Pasted image 20230522155831.png]]
- **EIP (Instruction Pointer Register)**: apunta a la siguiente instrucción a ser ejecutada por el programa. Cada vez que se ejecuta una instrucción, el procesador actualiza automáticamente el registro para que apunte a la siguiente.

## Instrucciones
- **MOV**: encargada de los accesos a memoria
	- `mov reg,  [DireccionMemoria]`: copia de la dirección de memoria al registro
	- `mov [DireccionMemoria], reg`: copia del registro a la dirección de memoria
	![[Pasted image 20230522192126.png]]
	- Con `[]` al segundo operando se le trata como un puntero (`mov eax, [ebx]`)
	![[Pasted image 20230522192434.png]]
	- Sin `[]` el segundo operando coge el contenido del registro (`mov eax, ebx`)
	![[Pasted image 20230522192520.png]]
- **PUSH/POP**: manipula una pila LIFO. Modifican el último valor de la pila. Cuando apilamos con push se resta y cuando desapilamos con pop se suma, esto es porque las direcciones más bajas de la pila son las primeras, es decir:
	![[Pasted image 20230522193501.png]]
- **Saltos (JMP, JE, JNE, CALL)**: pueden ser condicionales o incondicionales (siempre se han de cumplir)
	- El JNE depende del bit zero flag
	![[Pasted image 20230522193909.png]]
	- CALLS: 
	![[Pasted image 20230522194354.png]]
	Como no podemos conocer la dirección de memoria que tendrán los argumentos y las variables locales de una función al ejecutar un programa, usaremos el registro especial **EBP** (frame pointer o base pointer register). Estos parámetros son accedidos con un offset sobre el EBP.
	![[Pasted image 20230522194719.png]]
- **lea**: carga una dirección

## Prólogo de una función
- Son las instrucciones que modifican un registro para crear el heap de la función que se va a llamar.
1. `push ebp`: el valor del registro **ebp** se modifica en cada llamada a una función. Este valor permite acceder a las variables y parámetros de la función que realiza la llamada.
2. `mov ebp, esp`: se apunta el registro **ebp** al puntero de la pila, de esta manera se establece una dirección de referencia para el nuevo marco de la función llamada.

## Epílogo de una función
- Es su finalización (instrucción **leave**)
![[Pasted image 20230522195419.png]]
1. `mov esp, ebp`: deja de lado las variables locales de la función llamada y reestablece el tope de la pila
2. `pop ebp`: actualiza el registro ebp a la base del marco de la función que realizó la llamada anterior
3. `ret`: es un retorno desde una función llamada. Desapila una dirección del tope de la pila y la almacena en el registro EIP para ejecutar a continuación esa instrucción.

## Dirección de retorno
- La llamada a una función modifica el flujo de ejecución de un programa. Pero cuando una función termina de ejecutarse el control debe retornar a la función que realizó la llamada (un ejemplo sería que volviese al main())

![[Pasted image 20230522200417.png]]

## Reversing estático
- Consiste en analizar el código fuente sin ejecutar el binario asociado. No hay que hacer fuzzing.
- El depurador de Windows es una buena herramienta
![[Pasted image 20230522200719.png]]
![[Pasted image 20230522200924.png]]
- Haremos un análisis del código mediante el **tool objdump**
![[Pasted image 20230522201033.png]]
![[Pasted image 20230522201048.png]]
![[Pasted image 20230522201342.png]]
Función gets():
![[Pasted image 20230522201438.png]]
![[Pasted image 20230522201607.png]]

- Descargamos el **tool ghidra** para analizar los binarios
![[Pasted image 20230522202547.png]]
- Descargamos IDA64: https://tutorialforlinux.com/2023/01/30/ida-freeware-kali-linux-installation-step-by-step/3/
- Deshabilitar la asignación aleatoria de direcciones: `sudo sysctl -w kernel.randomize_va_space=0`
- Para hacer un desensamblado con el **tool objdump**: `objdump -M intel -S <archivo>`
- Para buscar el prólogo de una función con **objdump**: `objdump -M intel -S <archivo> | grep printf`