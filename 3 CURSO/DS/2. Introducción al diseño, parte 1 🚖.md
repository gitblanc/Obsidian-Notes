# 20 Sept 2022 
---
- El problema del software es que los requisitos van a **cambiar**. Por tanto, un c贸digo mal dise帽ado, en el momento funcionar谩, pero en un futuro es probable que deje de hacerlo, y si se dise帽a bien desde el principio ser谩 mucho m谩s f谩cil mantenerlo.
- El DOO (dise帽o orientado a objetos) construye las aplicaciones mediante una estructura de objetos que colaboran entre s铆.
- Cada objeto realiza unas operaciones que lo caracterizan (no importa c贸mo las realiza, sino cu谩les realiza)
- La implementaci贸n de esas operaciones son los **m茅todos**

- **Signatura de la operaci贸n**: cada operaci贸n declarada por un objeto espec铆fica (su nombre, los objetos que recibe como par谩metros y el tipo de valor devuelto por la operaci贸n).
- **Tipo**: nombre usado para denotar una determinada interfaz. Un objeto puede tener muchos tipos, as铆 como objetos muy diferentes pueden compartir un mismo tipo (**polimorfismo**)
- La operaci贸n que se ejecuta cuando se env铆a una petici贸n a un objeto depende de la **petici贸n** (el m茅todo) y del **objeto receptor** (figura.dibujar)
- El **enlace din谩mico** permite:
	- Escribir programas que esperen un objeto con una interfaz determinada, sabiendo que cualquier objeto que tenga esa interfaz aceptar谩 esa petici贸n.
- **Polimorfismo**: capacidad de dos o m谩s tipos de objetos de responder al mismo mensaje, cada uno a su manera. Nos permite tener una lista de figuras y poder dibujarlas todas sin conocerlas.

-  A - - - > B: A crea objetos de B, A implementa objetos de B
- A ------> B: 
- `<<create>>`: para definir tipos

## Creaci贸n de objetos
- Ya no s贸lo hay que decidir qu茅 hacer, sino tambi茅n qui茅n debe hacerlo (sis e aprende a hacer las cosas sin un qui茅n luego no se ve la necesidad de introducirlo)
- **S铆ntomas de programaci贸n estructurada encubierta**: **IMPORTANTE**
	- *M茅todos largos* (m谩s de 10 l铆neas). Si sucede mirar:
		- No est谩 delegando funcionalidad (un m茅todo que haga dos o m谩s cosas, s贸lo deber铆a hacer 1 cosa)
	- *Abundancia de llamadas a m茅todos del mismo objeto*
	- *Preguntarse c贸mo se calcula un factorial en un lenguaje OO* (lo importante es qui茅n lo va a hacer, no c贸mo)
	- *T铆pica clase utilidades* (Utils, Manager, ...). No se encuentra el qui茅n, por lo que se agrupan funcionalidades.

- **Atributos**: guardan el estado entre la invocaci贸n de un m茅todo a otro.
- **Regla para saber si es atributo o no**: 驴Ese dato afecta al comportamiento de otra operaci贸n como para que deba recordarlo?

## Criterios
- Un objeto no puede presuponer una secuencia de mensajes determinada
- Cada mensaje debe ser tratado de acuerdo al estado actual del objeto
- No debe haber ninguna secuencia de mensajes que corrompa al objeto

## Par谩metros
- Son la forma de enviar informaci贸n junto al mensaje
- **Los operandos** permanecen estables mientras que las opciones pueden variar a medida que la clase evolucione
- Un par谩metro es una opci贸n si se puede encontrar un valor predeterminado adecuado

## Encapsulaci贸n
- Normalmente no se debe dar acceso a los datos internos de un objeto (m茅todos get). Permite controlar las modificaciones del atributo.
- Hay que diferenciar entre **estado concreto** y **estado abstracto**.

## Lo que no funciona
- Basarse en objetos reales
- No sirve extraer nombres y verbos del lenguaje natural
- Adem谩s puede expresarse de varias maneras

## Gu铆a pr谩ctica
1. Elegir una tarea a realizar: el qu茅
	- Decidir qu茅 tipo de objeto lo har谩
	- 驴Puede hacerla alguna de las clases que ya tenemos?
2. Decidida la clase y la responsabilidad, tocan los mensajes (m茅todos), para dividir la responsabilidad en operaciones
3. Implementaci贸n de las operaciones
	- No preocuparse por la eficiencia hasta el final

---
Siguiente -> [[3. Introducci贸n al dise帽o, parte 2 ]]