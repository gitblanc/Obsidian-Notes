---
title: Apuntes de Patrones de Dise√±o üîã
---
>[!Note]
>Estos apuntes est√°n basados en el libro Patrones de Dise√±o de Erich Gamma junto con los apuntes de DS que nos proporciona la Universidad.
>
>En cada patr√≥n, los apartados de Motivaci√≥n y Estructura utiliza el segundo diagrama  (es decir, el que nos da C√©sar).
>
>Al final de cada patr√≥n hay un ejemplo que nos da C√©sar para entender el patr√≥n (que no deber√≠as de estudiarlo como tal, sino m√°s bien entenderlo)


## Strategy

### Prop√≥sito

Define una familia de algoritmos, encapsula cada uno de ellos y los hace intercambiables. Permite que un algoritmo var√≠e independientemente de los clientes que lo usan

### Tambi√©n conocido como

*Policy* (pol√≠tica)

### Motivaci√≥n

Existen muchos algoritmos para dividir en l√≠neas un flujo de texto. No resulta una buena pr√°ctica por varias razones:
- Los clientes que necesitan dividir el texto en l√≠neas se vuelven m√°s complejos si tienen que incluir dicho c√≥digo, lo que los hace m√°s grandes y m√°s dif√≠ciles de mantener
- No tenemos por qu√© permitir m√∫ltiples algoritmos si no los vamos a usar todos
- Es dif√≠cil a√±adir nuevos algoritmos o modificar los existentes

Estos problemas pueden evitarse definiendo clases que encapsulen los diferentes algoritmos de divisi√≥n en l√≠neas. Un algoritmo as√≠ encapsulado se denomina estrategia.

![](img/Pasted%20image%2020240603115339.png)

![](img/Pasted%20image%2020240603121408.png)

### Aplicabilidad

Usar el patr√≥n Strategy cuando:
- Muchas clases relacionadas difieren s√≥lo en su comportamiento
- Se necesitan distintas variantes de un algoritmo
- Un algoritmo usa datos que los clientes no deber√≠an conocer
- Una clase define muchos comportamientos, y √©stos se representan como m√∫ltiples sentencias condicionales en sus operaciones

### Estructura

![](img/Pasted%20image%2020240603115828.png)

![](img/Pasted%20image%2020240603121353.png)

### Participantes

- **Estrategia** (Componedor)
	- Declara una interfaz com√∫n a todos los algoritmos permitidos. El Contexto usa esta interfaz para llamar al algoritmo definido por una EstrategiaConcreta
- **EstrategiaConcreta** (ComponedorSimple, ComponedorTeX, ComponedorMatriz)
	- Implementa el algoritmo usando la interfaz Estrategia
- **Contexto** (Composicion)
	- Se configura con un objeto EstrategiaConcreta
	- Mantiene una referencia a un objeto Estrategia
	- Puede definir una interfaz que permita a la Estrategia acceder a sus datos

### Colaboraciones

- La estrategia y el contexto colaboran para implementar el algoritmo escogido
	- El contexto puede pasar todos los datos que necesita al llamar a la estrategia concreta
	- O se puede pasar a s√≠ mismo como referencia para que √©sta llame a los m√©todos que necesite
- Los clientes colaboran con el contexto
	- Pueden pasarle la estrategia concreta

### Consecuencias

- Define familias de algoritmos relacionados
- Es una alternativa a la herencia
	- Hace que el contexto sea m√°s f√°cil de entender, modificar y mantener
	- Evita la duplicaci√≥n de c√≥digo
	- Evita la explosi√≥n de subclases
	- Se puede cambiar din√°micamente
- Elimina las m√∫ltiples sentencias condicionales
- El cliente puede elegir entre varias implementaciones (incluso din√°micamente)
- Los clientes deben conocer las diferentes estrategias
- Puede complicarse la comunicaci√≥n entre el contexto y las estrategias
- Crece el n√∫mero de objetos

### Posibles usos

- Validadores de campos de formularios
- Distintas modalidades de juego
	- En un juego de p√≥quer, domin√≥, etc
	- Niveles de dificultad en el ajedrez o un simulador de coches

### Ejemplo que nos da C√©sar

![](img/Pasted%20image%2020240603120841.png)

*¬øC√≥mo hacemos para que ahora vuelen?*

![](img/Pasted%20image%2020240603120946.png)

>[!Error]
>Esto conlleva un problema
>- Ahora tenemos un mont√≥n de patos de goma volando por la pantalla
>- Al implementar `volar` en la superclase, hemos dado esa habilidad a todos los patos, incluyendo aquellos que no deber√≠an

Una posibilidad ser√≠a que el `volar` en `PatoDeGoma` no hiciese nada (estuviese vac√≠o)

**Soluci√≥n:**

![](img/Pasted%20image%2020240603121214.png)

## Factory Method

### Prop√≥sito

Define una interfaz para crear un objeto, pero deja que sean las subclases quienes decidan qu√© clase instanciar. Permite que una clase delegue en sus subclases la creaci√≥n de objetos

### Tambi√©n conocido como

*Virtual Constructor* (Constructor Virtual)

### Motivaci√≥n

- Sea un framework para la construcci√≥n de editores de documentos de distintos tipos
	- Clases abstractas `Application` y `Document`
		- Los clientes deber√°n heredar de ellas para implementar los detalles de cada aplicaci√≥n concreta
		- P. ej. `DrawingApplication` y `DrawingDocument`
	- ¬øC√≥mo se implementa la opci√≥n `New` del men√∫?
	- ¬øC√≥mo sabe la clase `Application` qu√© tipo concreto del documento debe crear?

Llamaremos a `CrearDocumento` un m√©todo de fabricaci√≥n porque es el responsable de "fabricar" un objeto

![](img/Pasted%20image%2020240603123616.png)

![](img/Pasted%20image%2020240603123630.png)

### Aplicabilidad

√ösese el patr√≥n Factory Method cuando:
- Una clase no puede anticipar la clase de objetos que debe crear
- Una clase quiere que sean sus subclases quienes especifiquen los objetos que √©sta crea
- Las clases delegan la responsabilidad en una de entre varias subclases, y queremos localizar qu√© subclase concreta es en la que se delega

### Estructura

![](img/Pasted%20image%2020240603124130.png)

![](img/Pasted%20image%2020240603124302.png)

### Participantes

- **Producto** (Documento)
	- Define la interfaz de los objetos que crea el m√©todo de fabricaci√≥n
- **ProductoConcreto** (MiDocumento)
	- implementa la interfaz del Producto
- **Creador** (Aplicacion)
	- Declara el m√©todo de fabricaci√≥n, el cual devuelve un objeto de tipo Producto. 
	- Puede definir una implementaci√≥n predeterminada del m√©todo de fabricaci√≥n que devuelva un objeto ProductoConcreto
	- Puede llamar al m√©todo de fabricaci√≥n para crear un objeto Producto
- **CreadorConcreto** (MiAplicacion)
	- Redefine el m√©todo de fabricaci√≥n para devolver una instancia de un ProductoConcreto

### Colaboraciones

- El Creador se apoya en sus subclases para definir el m√©todo de fabricaci√≥n que devuelve una instancia del ProductoConcreto apropiado

### Consecuencias

- Elimina la necesidad de enlazar clases espec√≠ficas de la aplicaci√≥n en el c√≥digo
	- S√≥lo maneja la interfaz `Product`
		- Por lo que permite a√±adir cualquier clase `ConcreteProduct` definida por el usuario
- **Inconveniente**:
	- Tener que crear una subclase de `Creator` en los casos en los que √©sta no fuera necesaria de no aplicar el patr√≥n
- En los ejemplos anteriores, el m√©todo de fabricaci√≥n era llamado √∫nicamente por el creador y sus subclases. No tiene por qu√© ser siempre as√≠: hay veces en que puede ser el cliente quien se encargue de ello
	- Por ejemplo en los casos de **jerarqu√≠as paralelas**

![](img/Pasted%20image%2020240603125322.png)

## Abstract Factory

### Prop√≥sito

Proporciona una interfaz para crear familias de objetos relacionados o que dependen entre s√≠, sin especificar sus clases concretas

### Tambi√©n conocido como

*Kit*

### Motivaci√≥n

- Sea una biblioteca gr√°fica que permita generar interfaces para diferentes entornos de ventanas
	- Cada uno de ellos tendr√° una clase distinta para representar una ventana, una barra de desplazamiento, un bot√≥n...
- Si queremos que una aplicaci√≥n se aproveche de ello y sea portable, no podr√° crear directamente objetos de esas clases espec√≠ficas

![](img/Pasted%20image%2020240603125907.png)

![](img/Pasted%20image%2020240603125958.png)

### Aplicabilidad

√ösese el patr√≥n Abstract Factory cuando:
- Un sistema debe ser independiente de c√≥mo se crean, componen y representan sus productos
- Un sistema debe ser configurado con un una familia de productos de entre varias
- Una familia de objetos producto relacionados est√° dise√±ada para ser usada conjuntamente, y es necesario hacer cumplir esta restricci√≥n
- Quiere proporcionar una biblioteca de clases de productos, y s√≥lo quiere revelar sus interfaces, no sus implementaciones

### Estructura

![](img/Pasted%20image%2020240603130255.png)

### Participantes

- **FabricaAbstracta** (FabricaDeUtiles)
	- Declara una interfaz para operaciones que crean objetos producto abstractos
- **FabricaConcreta** (FabricaDeUtilesMotif, FabricaDeUtilesPM)
	- Implementa las operaciones para crear objetos producto concretos
- **ProductoAbstracto** (Ventana, BarraDeDesplazamiento)
	- Declara una interfaz para un tipo de objeto producto
- **Producto Concreto** (VentanaMotif, BarraDeDesplazamientoMotif)
	- Define un objeto producto para que sea creado por la f√°brica correspondiente
	- Implementa la interfaz ProductoAbstracto
- **Cliente**
	- S√≥lo usa interfaces declaradas por las clases FabricaAbstracta y ProductoAbstracto

### Consecuencias

- A√≠sla las clases concretas
	- Los clientes manipulan los productos √∫nicamente a trav√©s de sus interfaces abstractas, gracias a que las clases de productos concretos est√°n encapsuladas en cada f√°brica concreta, no aparecen en el c√≥digo
- Permite intercambiar f√°cilmente familias de productos
	- Basta con cambiar una √∫nica clase, en un √∫nico sitio: la f√°brica concreta
- Promueve la consistencia entre los productos
	- S√≥lo se pueden usar conjuntamente los objetos de cada familia
- Dificulta a√±adir nuevos tipos de productos
	- Hay que cambiar la interfaz de la f√°brica abstracta y por tanto implementar el nuevo m√©todo en todas sus subclases

### Implementaci√≥n

- Las f√°bricas pueden ser `Singletons`
- Crear los productos
	- Normalmente, el `Abstract factory` emplea a su vez un `Factory Method` para cada producto
		- Sencillo, pero requiere crear una subclase por cada familia
	- Otra posibilidad es emplear el patr√≥n `Prototype`: una √∫nica clase para la f√°brica abstracta y tener distintos objetos de la misma configurados mediante prototipos
- F√°bricas extensibles
	- Pretenden resolver el problema de poder a√±adir nuevos tipos de productos
	- Un √∫nico m√©todo de creaci√≥n especificando el tipo de producto como par√°metro
	- M√°s flexible, pero menos seguro (se pierde la comprobaci√≥n est√°tica de tipos)

## Factory Method vs Abstract Factory

![](img/Pasted%20image%2020240603131608.png)

## Composite

### Prop√≥sito

Compone objetos en estructuras de √°rbol para representar jerarqu√≠as de parte/todo. Permite que los clientes traten de manera uniforme a los objetos individuales y a los compuestos

### Motivaci√≥n

- Un editor de dibujo permite realizar dibujos compuestos de elementos simples (l√≠neas, rect√°ngulos...) u otros dibujos
	- ¬øC√≥mo evitamos que los clientes tengan que distinguir entre unos y otros?

![](img/Pasted%20image%2020240603132417.png)

![](img/Pasted%20image%2020240603132441.png)

### Aplicabilidad

Usar el patr√≥n Composite cuando:
- Quiera representar jerarqu√≠as de objetos parte-todo
- Quiera que los clientes traten por igual los objetos y los objetos individuales

### Estructura

![](img/Pasted%20image%2020240603132655.png)

![](img/Pasted%20image%2020240603132735.png)

![](img/Pasted%20image%2020240603132753.png)

### Participantes

- **Componente** (Grafico)
	- Declara la interfaz com√∫n
	- Implementa el comportamiento predeterminado de la interfaz que es com√∫n a todas las clases
	- Declara operaciones para acceder a sus hijos (aunque no necesariamente, pues pueden declararse en el compuesto)
	- (opcional) Define una interfaz para acceder al padre
- **Hoja** (Rectangulo, Linea, Texto...)
	- Representa objetos hoja en la composici√≥n
	- Una hoja no tiene hijos
- **Compuesto** (Dibujo)
	- Almacena sus componentes hijos
	- Implementa las operaciones relacionadas con los hijos
- **Cliente**
	- Manipula los objetos de la composici√≥n a trav√©s de la interfaz de Componente

### Consecuencias

- Permite jerarqu√≠as de objetos tan complejas como se quiera
	- All√° donde el cliente espere un objeto primitivo, podr√° recibir un compuesto y no se dar√° cuenta
- Simplifica el cliente
	- Al eliminar el c√≥digo para distinguir entre unos y otros
- Se pueden a√±adir nuevos componentes f√°cilmente
- Como desventaja, podr√≠a hacer el dise√±o demasiado general

### Implementaci√≥n

- Referencias expl√≠citas al padre
- Maximizar la interfaz de *Component*
	- El componente puede proporcionar implementaciones predeterminadas que luego las clases hoja y las compuestas redefinan
	- Problema: puede haber operaciones que tengan sentido en unas pero no en otras
		- Ejemplo: las operaciones de gesti√≥n de los hijos
- Orden de los hijos
	- Si es significativo, hay que dise√±ar las interfaces de acceso y gesti√≥n de los hijos cuidadosamente

## State

### Prop√≥sito

Permite que un objeto modifique su comportamiento cada vez que cambie su estado interno. Parecer√° que cambia la clase del objeto

### Tambi√©n conocido como

*Objects for States* (Estados como Objetos)

### Motivaci√≥n

- Una conexi√≥n de red es representada en una implementaci√≥n TCP como TCPConnection
- La conexi√≥n puede estar en uno de los siguientes estados:
	- Abierta
	- Escuchando
	- Cerrada

![](img/Pasted%20image%2020240603144016.png)

### Aplicabilidad

√ösese el patr√≥n State en cualquiera de los siguientes casos:
- El comportamiento de un objeto depende de su estado, y √©ste puede cambiar en tiempo de ejecuci√≥n
- Las operaciones tienen largas sentencias condicionales anidadas que tratan con los estados
	- Siendo el estado normalmente una constante
	- Muy frecuentemente, son varias las operaciones en las que se repite esa misma estructura condicional
	- Este patr√≥n mueve cada rama de la l√≥gica condicional a una clase aparte
		- Lo que nos permite tratar al estado del objeto como un objeto de pleno derecho, que puede variar independientemente de otros objetos

### Estructura

![](img/Pasted%20image%2020240603144412.png)

![](img/Pasted%20image%2020240603144426.png)

### Participantes

- **Contexto** (ConexionTCP)
	- Define la interfaz de inter√©s para los clientes
	- Mantiene una instancia de una subclase de EstadoConcreto que define el estado actual
- **Estado** (EstadoTCP)
	- Define una interfaz para encapsular el comportamiento asociado con el estado del Contexto
- **subclases del EstadoConcreto** (TCPEstablecida, TCPEscuchando, TCPCerrada)
	- Cada subclase implementa un comportamiento asociado con un estado del Contexto

### Colaboraciones

- El Contexto delega las operaciones dependientes del estado al objeto que representa el estado actual
- El contexto podr√≠a pasarse a s√≠ mismo como par√°metro
	- Para que el estado acceda al contexto si es necesario
- una vez que el Contexto es inicializado en un determinado estado, los clientes no necesitan tratar directamente con los estados
- O bien el Contexto o bien los EstadosConcretos deciden cu√°ndo se pasa de un estado a otro

### Consecuencias

- Localiza el comportamiento espec√≠fico del estado y lo a√≠sla en un objeto
	- Se pueden a√±adir nuevos estados y transiciones f√°cilmente simplemente definiendo nuevas subclases de `State`
- Hace expl√≠citas las transiciones entre estados

### Implementaci√≥n

- ¬øQui√©n define las transiciones entre estados?
	- Si el criterio es siempre el mismo, puede ser el propio contexto
	- Normalmente es m√°s flexible y apropiado que sean las subclases de los estados
		- Esto requiere a√±adir una operaci√≥n al contexto para cambiar su estado de forma expl√≠cita
		- **Ventaja**: flexibilidad
		- **Inconveniente**: dependencias de implementaci√≥n (acoplamiento) entre las subclases que representan los estados concretos
- Uso de la herencia din√°mica
	- Este patr√≥n no ser√≠a necesario en lenguajes que permiten cambiar la clase de un objeto en tiempo de ejecuci√≥n o que proveen mecanismos para delegar peticiones autom√°ticamente en otros objetos
- Acciones de entrada/salida
	- Cuando hay que realizar alguna acci√≥n al entrar o salir de un estado puede venir bien a√±adir un m√©todo `entry`, `exit` o ambos a la interfaz `State`

### Posibles usos

![](img/Pasted%20image%2020240603145625.png)

## State vs Strategy

- **Strategy**: es seleccionada por un agente externo o por el contexto. Una estrategia tiende a tener un m√©todo √∫nico de "inicio" que llama a todos los dem√°s. Hay mucha cohesi√≥n entre los m√©todos de un Strategy
- **State**: un State generalmente selecciona el siguiente estado de su contexto. Un estado tiende a tener muchos m√©todos no relacionados, por lo que hay poca cohesi√≥n entre los m√©todos de un State
	- Los m√©todos del State suelen llamarse igual y tener la misma signatura que las que ten√≠an dicho subconjunto de operaciones en el contexto

## Template Method

### Prop√≥sito

Define en una operaci√≥n el esqueleto de un algoritmo, delegando en las subclases algunos de sus pasos. Permite que las subclases redefinan ciertos pasos de un algoritmo sin cambiar su estructura

### Motivaci√≥n

- Sea un framework de aplicaciones que proporciona unas clases `Application` y `Document`
	- La primera es la responsable de abrir los documentos almacenados en ficheros
	- La segunda representa la informaci√≥n en s√≠ del documento, una vez que ya ha sido le√≠do del fichero
- Las aplicaciones construidas con el framework redefinir√°n ambas clases para adaptarlas a sus necesidades concretas
- ¬øC√≥mo implementar, de manera gen√©rica, el m√©todo `openDocuiment` de la clase `Application`?

![](img/Pasted%20image%2020240603151045.png)

- El m√©todo abstracto anterior define todos los pasos necesarios para abrir un documento
	- Comprueba si se puede abrir, crea un objeto `Document`, lo a√±ade al conjunto de documentos y finalmente lo lee
	- Lo hace en t√©rminos de operaciones abstractas

![](img/Pasted%20image%2020240603151215.png)

### Aplicabilidad

El patr√≥n Template Method deber√≠a usarse:
- Para implementar las partes de un algoritmo que no cambian y dejar que sean las subclases quienes implementen el comportamiento que puede variar
- Como motivo de factorizar c√≥digo, cuando movemos cierto c√≥digo a una clase base com√∫n para evitar c√≥digo duplicado
- Para controlar el modo en que las subclases extienden la clase base
	- Dejando que sea s√≥lo a trav√©s de unos m√©todos plantilla dados

### Estructura

![](img/Pasted%20image%2020240603151421.png)

![](img/Pasted%20image%2020240603151434.png)

### Participantes

- **ClaseAbstracta** (Application)
	- Define las operaciones primitivas abstractas que redefinir√°n las subclases
	- Implementa un m√©todo de plantilla con el esqueleto del algoritmo
- **ClaseConcreta** (MiApplication)
	- Implementa las operaciones primitivas para realizar los pasos del algoritmo espec√≠ficos de las subclases

### Consecuencias

- Los m√©todos de plantilla son una t√©cnica fundamental para la reutilizaci√≥n de c√≥digo
- Inversi√≥n de control
	- Es la clase padre quien llama a operaciones en los hijos
- Los m√©todos de plantilla pueden llamar a los siguientes tipos de operaciones:
	- Operaciones concretas de otras clases
	- Operaciones concretas en la propia clase base abstracta
		- Proporcionan comportamiento predeterminado que las subclases pueden redefinir si es necesario
	- Operaciones primitivas (es decir, abstractas)
		- Que las subclases deber√°n implementar
	- M√©todos de fabricaci√≥n
	- Operaciones de enganche (*hook*)
		- Normalmente protegidas, tienen una implementaci√≥n vac√≠a en la clase abstracta, que las subclases podr√°n redefinir. Son como operaciones opcionales

Operaciones de enganche:

![](img/Pasted%20image%2020240603152121.png)

![](img/Pasted%20image%2020240603152142.png)

### Implementaci√≥n

- Hacer las operaciones primitivas llamadas por el m√©todo de plantilla `protected`
	- Y, a aqu√©llas que deban ser obligatoriamente redefinidas, abstractas
- Minimizar el n√∫mero de operaciones primitivas abstractas
- Convenios de nombrado
	- Es conveniente identificar las operaciones que deben ser redefinidas anteponiendo un prefijo al nombre (ej: `Do-`)

### Patrones relacionados

- *Factory Method*
	- Muchas veces los m√©todos de fabricaci√≥n son llamados desde m√©todos plantilla
- *Strategy*
	- El *Template Method* usa la herencia para modificar parte de un algoritmo; *Strategy* usa delegaci√≥n para cambiar el algoritmo entero

## Adapter

### Prop√≥sito

Convierte la interfaz de una clase en otra interfaz que es la que esperan los clientes. Permite que cooperen clases que de otra forma no podr√≠an tener interfaces compatibles

### Tambi√©n conocido como

*Wrapper* (Envoltorio)

### Motivaci√≥n

- Supongamos que estamos haciendo un editor de dibujo
	- La abstracci√≥n fundamental es el objeto gr√°fico (`Shape`), que puede dibujarse a s√≠ mismo
	- Define una subclase por cada tipo de objeto gr√°fico: `LineShape`, `PolygonShape`...
- Supongamos que, para implementar una subclase `TextShape` (bastante m√°s compleja que las anteriores) queremos echar mano de una clase `TextView` que nos proporciona la biblioteca gr√°fica
- La interfaz de `TextView` no tendr√° nada que ver con la de `Shape`
	- Le faltar√°n algunas operaciones, otras las tendr√° con otro nombre, o bien recibir√°n par√°metros de otro tipo...
- Crearemos una clase `TextShape` que adapte la interfaz `TextView` a la de `Shape`
- Dos opciones:
	- Heredando la interfaz de `Shape` y la implementaci√≥n de `TextView` (versi√≥n de dos clases)
	- Mediante composici√≥n de objetos, haciendo que `TextShape` delegue en una instancia de `TextView` (versi√≥n de objetos)

![](img/Pasted%20image%2020240603153138.png)

### Aplicabilidad

Deber√≠a usarse el patr√≥n Adapter cuando:
- Se quiere usar una clase existente y su interfaz no concuerda con la que necesita
- Se quiere crear una clase reutilizable que coopere con clases con las que no est√° relacionada (que no tendr√°n interfaces compatibles)
- (S√≥lo la versi√≥n de objetos) Necesitamos usar varias subclases existentes pero sin tener que adaptar su interfaz creando una nueva subclase de cada una

### Estructura

![](img/Pasted%20image%2020240603153436.png)

![](img/Pasted%20image%2020240603153455.png)

![](img/Pasted%20image%2020240603153527.png)

![](img/Pasted%20image%2020240603153545.png)

### Participantes

- **Objetivo** (Forma)
	- Define la interfaz espec√≠fica del dominio que usa el Cliente
- **Cliente** (EditorDeDibujo)
	- Colabora con objetos que se ajustan a la interfaz Objetivo
- **Adaptable** (VistaTexto)
	- Define una interfaz existente que necesita ser adaptada
- **Adaptador** (FormaTexto)
	- Adapta la interfaz de Adaptable a la interfaz Objetivo

### Consecuencias

Las versiones de clases y de objetos de este patr√≥n tienen diferentes ventajas e inconvenientes:
- **Un adaptador de clases**:
	- Adapta una clase concreta a una interfaz (no se puede usar cuando queremos adaptar una clase y todas sus subclases)
	- Permite que el adaptador redefina parte del comportamiento de la clase adaptada (es una subclase de aqu√©lla)
	- Introduce un solo objeto adicional, sin indirecci√≥n
- **Un adaptador de objetos**
	- Permite que un √∫nico adaptador funcione no s√≥lo con un objeto de la clase adaptada, sino de cualquiera de sus subclases
	- Permite adaptar objetos existentes
	- No es del tipo de objeto adaptado

## Command

### Prop√≥sito

Encapsula una petici√≥n en un objeto, permitiendo as√≠ parametrizar a los clientes con diferentes peticiones, hacer cola o llevar un registro de las peticiones, y poder deshacer las operaciones

### Tambi√©n conocido como

*Action* (Acci√≥n), *Transaction* (Transacci√≥n)

### Motivaci√≥n

- Una biblioteca de clases para interfaces de usuario tendr√° objetos como botones y elementos de men√∫ responsables de realizar alguna operaci√≥n en respuesta a una entrada del usuario
- La biblioteca no puede implementar dichas operaciones directamente en el bot√≥n o el men√∫
	- S√≥lo las aplicaciones que usan la biblioteca saben qu√© hay que hacer y a qu√© operaciones de otros objetos hay que llamar

![](img/Pasted%20image%2020240603161258.png)

- La clave de este patr√≥n es una interfaz `Command` que define una operaci√≥n `execute`
- Son las subclases concretas quienes implementan la operaci√≥n y especifican el receptor de la orden
- Podemos configurar cada elemento del men√∫, `MenuItem`, con un objeto `Command`
- Los elementos del men√∫ no saben qu√© objeto concreto est√°n usando (simplemente llaman a su m√©todo `execute`)

![](img/Pasted%20image%2020240603161523.png)

![](img/Pasted%20image%2020240603161537.png)

### Aplicabilidad

√ösese el patr√≥n Command cuando se quiera:
- Parametrizar objetos con una acci√≥n a realizar
- Especificar, guardar y ejecutar peticiones en distintos momentos
	- Es decir, que la acci√≥n a realizar y el objeto que la crea tengan ciclos de vida distintos (desacoplamiento temporal)
- Permitir deshacer/repetir (undo/redo)
	- En ese caso, `execute` deber√° guardar el estado para poder revertir los efectos de ejecutar la operaci√≥n
	- Y har√° falta una operaci√≥n a√±adida, `unexecute`
- Guardar todas las operaciones ejecutadas en un registro (log)
	- Proporcionando un par de operaciones `store` y `load`
- Usar transacciones

### Estructura

![](img/Pasted%20image%2020240603161915.png)

![](img/Pasted%20image%2020240603161931.png)

### Participantes

- **Orden** (Command)
	- Define una interfaz para ejecutar una operaci√≥n
- **OrdenConcreta** (ConcreteCommand, OpenCommand...)
	- Define un enlace entre un objeto receptor y una acci√≥n
	- Implementa `execute` llamando a las operaciones de dicho receptor
- **Cliente** (Aplicaci√≥n)
	- Crea un objeto OrdenConcreta (ConcreteCommand) y establece su receptor
- **Invocador** (ElementoDeMenu)
	- Le pide a la orden que ejecute la petici√≥n
- **Receptor** (Documento, Aplicacion)
	- Quien realmente lleva a cabo la acci√≥n.

### Colaboraciones

- El cliente crea un objeto `ConcreteCommand` y especifica su receptor
- Un objeto `Invoker` guarda el objeto `ConcreteCommand`
- Aqu√©l llama a la operaci√≥n de este √∫ltimo
	- Quien antes guarda el estado par luego poder deshacer la operaci√≥n (si son operaciones que se pueden deshacer)
- El objeto `ConcreteCommand` se vale de las operaciones de su receptor para llevar a cabo la acci√≥n

![](img/Pasted%20image%2020240603162626.png)

### Consecuencias

- Desacopla el objeto que llama a la operaci√≥n del que sabe c√≥mo llevarla a cabo
- Son ciudadanos de primera clase (objetos)
- Se pueden ensamblar (Composite)
- Resulta sencillo a√±adir nuevas acciones, al no tener que tocar las clases existentes

### Implementaci√≥n

- ¬øC√≥mo de inteligente deber√≠a ser?
	- Desde un mero enlace entre el receptor y las operaciones a realizar en √©l hasta implementarlo todo √©l solo sin especificar un receptor
- Diferentes niveles de deshacer/repetir
	- A veces ser√° necesario crear una copia del objeto antes de guardarlo en el historial
		- En este caso, los Command ser√≠an tambi√©n Prototype

### Ejemplo de C√©sar

![](img/Pasted%20image%2020240603163102.png)

![](img/Pasted%20image%2020240603163117.png)

## Decorator

### Prop√≥sito

Asigna responsabilidades adicionales a un objeto din√°micamente , proporcionando una alternativa flexible a la herencia para extender la funcionalidad

### Tambi√©n conocido como

*Wrapper* (Envoltorio)

### Motivaci√≥n

- A veces queremos a√±adir responsabilidades a objetos individuales, no a toda una clase

![](img/Pasted%20image%2020240604105933.png)

- Primera alternativa: mediante la herencia

![](img/Pasted%20image%2020240604110007.png)

>[!Problem]
>- **Inflexible**: la elecci√≥n del borde se hace est√°ticamente, no la puede hacer el cliente
>- **Explosi√≥n de clases**: ¬øqu√© pasar√≠a si queremos un `TextView` con borde y barra de desplazamiento?

- Una soluci√≥n m√°s flexible es envolver el componente en otro objeto que sea quien a√±ada el borde
	- Este objeto envoltorio es el decorador
- El decorador sigue cumpliendo la interfaz del objeto original, as√≠ que su presencia es transparente para los clientes del componente
	- El decorador delega las peticiones al componente y puede llevar a cabo acciones adicionales
	- La transparencia permite anidar decoradores de forma recursiva

![](img/Pasted%20image%2020240604110330.png)

![](img/Pasted%20image%2020240604110345.png)
### Aplicabilidad

Use el Decorator:
- Para a√±adir responsabilidades a otros objetos din√°micamente y de forma transparente
- Cuando no se puede heredar o no resulta pr√°ctico (explosi√≥n de subclases para permitir cada combinaci√≥n posible)
### Estructura

![](img/Pasted%20image%2020240604110542.png)

En UML:

![](img/Pasted%20image%2020240604110608.png)

### Participantes

- **Componente** (ComponenteVisual)
	- Define la interfaz de los objetos a los que se les puede a√±adir responsabilidades din√°micamente
- **ComponenteConcreto** (VistaTexto)
	- Define un objeto al que se le pueden a√±adir responsabilidades adicionales
- **Decorador**
	- Mantiene una referencia a un objeto Componente y tiene su misma interfaz
- **DecoradorConcreto** (DecoradorBorde, DecoradorDesplazamiento)
	- A√±ade responsabilidades al componente

### Consecuencias

- **Ventajas**:
	- M√°s flexibilidad que la herencia est√°tica
	- Evita que las clases de arriba de la jerarqu√≠a est√©n repletas de funcionalidades
- **Inconvenientes**:
	- Un decorador y sus componentes no son id√©nticos
		- Desde el punto de vista de la identidad de objetos
	- Muchos objetos peque√±os
		- Mayor dificultad para depurar

### Implementaci√≥n

![](img/Pasted%20image%2020240604111904.png)

### Posibles usos

![](img/Pasted%20image%2020240604111939.png)

### Patrones relacionados

- **Adapter**:
	- El Decorador s√≥lo cambia las responsabilidades del objeto, no su interfaz
- **Composite**:
	- Un Decorador puede verse como un Composite de un solo componente
	- Pero el decorador a√±ade responsabilidades adicionales (no est√° pensado para la agregaci√≥n de objetos)
- **Strategy**:
	- El decorador cambia la piel del objeto; una estrategia cambia sus tripas

### Ejemplo real

![](img/Pasted%20image%2020240604112141.png)

![](img/Pasted%20image%2020240604112213.png)

## Observer

### Prop√≥sito

Define una dependencia de uno-a-muchos entre objetos, de forma que cuando un objeto cambie de estado se notifique y se actualicen autom√°ticamente todos los objetos que dependen de √©l

### Tambi√©n conocido como

*Dependents* (Dependientes), *Publish-Subscribe* (Publicar-Suscribir)

### Motivaci√≥n

- Muchas veces un efecto lateral de partir un sistema en una colecci√≥n de objetos relacionados es que necesitamos mantener la consistencia entre dichos objetos
	- ¬øC√≥mo hacerlo sin que sus clases est√©n fuertemente acopladas?

![](img/Pasted%20image%2020240604112622.png)

![](img/Pasted%20image%2020240604112643.png)

### Aplicabilidad

√ösese el patr√≥n Observer:
- Cuando una abstracci√≥n tiene dos aspectos, uno de los cuales depende del otro
	- Encapsular estos aspectos en objetos separados permite que los objetos var√≠en (y puedan ser reutilizados) de forma independiente
- Cuando un cambio en un objeto requiere que cambien otros
	- Y no sabemos a priori cu√°les ni cu√°ntos
- Cuando un objeto necesita notificar a otros cambios en su estado sin hacer presunciones sobre qui√©nes son dichos objetos
	- Es decir, cuando no queremos que est√©n fuertemente acoplados

### Estructura

![](img/Pasted%20image%2020240604112933.png)

![](img/Pasted%20image%2020240604112950.png)

![](img/Pasted%20image%2020240604113020.png)

### Participantes

- **Sujeto** (Subject)
	- Conoce a sus observadores
	- Proporciona una interfaz para que se suscriban los objetos Observer (o que se borren)
- **Observador** (Observer)
	- Define una interfaz para actualizar los objetos que deben ser notificados de cambios en el objeto Subject
- **SujetoConcreto** (ConcreteSubject)
	- Guarda el estado de inter√©s para los objetos ConcreteObserver
	- Env√≠a una notificaci√≥n a sus observadores cuando cambia su estado
- **ObservadorConcreto** (ConcreteObserver)
	- Mantiene una referencia a un objeto ConcreteSubject
	- Guarda el estado que deber√≠a permanecer sincronizado con el objeto observado
	- Implementa la interfaz Observer para mantener su estado consistente con el objeto observado

### Colaboraciones

- El objeto observado notifica a sus observadores cada vez que ocurre un cambio
- Despu√©s de ser informado de un cambio en el objeto observado, cada observador concreto puede pedirle informaci√≥n que necesita para reconciliar su estado con el de aqu√©l

![](img/Pasted%20image%2020240604113738.png)

### Consecuencias

- Permite variar objetos observados y observadores independientemente
	- Se puede reutilizar los objetos observados sin sus observadores, y viceversa
	- Se pueden a√±adir nuevos observadores sin modificar ninguna de las clases existentes
- Acoplamiento abstracto entre Subject y Observer
	- Todo lo que un objeto sabe de sus observadores es que tiene una lista de objetos que satisfacen la interfaz Observer
- No se especifica el receptor de una actualizaci√≥n
	- Se env√≠a a todos los objetos interesados
- Actualizaciones inesperadas
	- Se podr√≠an producir actualizaciones en cascada muy ineficientes

### Implementaci√≥n

- En vez de mantener una colecci√≥n con referencias expl√≠citas a los observadores en el objeto observado, ser√≠a posible hacerlo con una tabla hash que relacionase ambos
- Cuando un observador dependa de m√°s de un objeto, es necesario ampliar la informaci√≥n de la operaci√≥n `update`
- ¬øQui√©n se encarga de llamar a la actualizaci√≥n (`notify`)?
	- El objeto observado, cada vez que cambia su estado
	- Los clientes
		- M√°s propenso a errores
- Protocolos de actualizaci√≥n
	- Modelo push
		- El objeto observado env√≠a informaci√≥n detallada a sus observadores sobre el cambio producido (la necesiten o no)
	- Modelo pull
		- Tan s√≥lo avisa de que cambi√≥

## Visitor

### Prop√≥sito

Representa una operaci√≥n sobre los elementos de una estructura de objetos. Permite definir una nueva operaci√≥n sin cambiar las clases de los elementos sobre los que opera

### Motivaci√≥n

- Un compilador suele representar los programas mediante una estructura de √°rbol
- Necesitar√° realizar operaciones como:
	- An√°lisis sint√°ctico
	- An√°lisis sem√°ntico
	- Generaci√≥n de c√≥digo
	- ...
- Normalmente tendremos clases distintas para las distintas construcciones del lenguaje (referencias a variables, sentencias de asignaci√≥n...)
- Ser√°n los nodos del √°rbol

![](img/Pasted%20image%2020240604115248.png)

![](img/Pasted%20image%2020240604115308.png)

![](img/Pasted%20image%2020240604115330.png)

- Encapsulamos cada tipo de operaci√≥n en una clase "visitor" y se la pasamos al √°rbol
	- Los nodos definir√°n una operaci√≥n para aceptar visitantes
	- Y llamar√°n a su vez a la operaci√≥n apropiada del visitante pas√°ndose a s√≠ mismos como par√°metros

![](img/Pasted%20image%2020240604115510.png)

![](img/Pasted%20image%2020240604115531.png)

- Lo que se hace es simular el **despacho doble** (double dispatch)

### Aplicabilidad

√ösese el patr√≥n Visitor cuando:
- Una estructura de objetos contiene muchas clases de objetos con diferentes interfaces, y queremos realizar operaciones sobre esos elementos que dependen de su clase concreta
- Se necesitan realizar muchas operaciones distintas y no relacionadas sobre objetos de una estructura de objetos, y queremos evitar "contaminar" sus clases con dichas operaciones
	- Con el Visitor se pueden mantener juntas operaciones relacionadas en una clase

Deber√≠a aplicarse el patr√≥n Visitor cuando:
- Las clases que definen la estructura de objetos rara vez cambian, pero muchas veces queremos definir nuevas operaciones sobre la estructura

### Estructura

![](img/Pasted%20image%2020240604120138.png)

![](img/Pasted%20image%2020240604120156.png)

### Participantes

- **Visitante** (Visitor, NodeVisitor)
	- Declara una operaci√≥n `visit` para cada clase de operaci√≥n `ConcreteElement` de la estructura de objetos
	- El nombre (opcional) y signatura de la operaci√≥n identifican a la clase que env√≠a la petici√≥n visit al visitante
- **VisitanteConcreto** (ConcreteVisitor, TypeCheckingVisitor)
	- Implementa cada operaci√≥n declarada por `Visitor`
	- Cada operaci√≥n implementa un fragmento del algoritmo definido para la clase correspondiente de la estructura
	- `ConcreteVisitor` proporciona el contexto para el algoritmo y guarda su estado local
- **Elemento** (Element, Node)
	- Define una operaci√≥n `accept` que recibe un visitante como argumento
- **ElementoConcreto** (ConcreteElement, AssignmentNode, VariableRefNode)
	- Implementa una operaci√≥n `accept` que recibe un visitante como argumento
- **EstructuraDeObjetos** (ObjectStructure, Program)
	- Permite enumerar sus elementos
	- Puede proporcionar una interfaz de alto nivel para permitir al visitante visitar a sus elementos
	- Puede ser un compuesto (patr√≥n Composite) o una colecci√≥n, como una lista o un conjunto

### Colaboraciones

- Un cliente que usa el patr√≥n **Visitor** debe crear un objeto **ConcreteVisitor** y a continuaci√≥n recorrer la estructura, visitando cada objeto con el visitante
- Cada vez que se visita a un elemento, √©ste llama a la operaci√≥n del **Visitor** que se corresponde con su clase
	- El elemento se pasa a s√≠ mismo como argumento de la operaci√≥n

![](img/Pasted%20image%2020240604120930.png)

### Consecuencias

- El visitante facilita a√±adir nuevas operaciones
	- Podemos definir una nueva operaci√≥n sobre una estructura simplemente a√±adiendo un nuevo visitante
	- Si, por el contrario, extendi√©semos la funcionalidad sobre muchas clases, habr√≠a que cambiar cada clase para definir una nueva operaci√≥n
- Un visitante agrupa operaciones relacionadas y separa las que no lo est√°n
- Es dif√≠cil a√±adir nuevas clases de elementos concretos

## Prototype

### Prop√≥sito

Especifica los tipos de objetos a crear por medio de una instancia protot√≠pica, y crea nuevos objetos copiando dicho prototipo
- B√°sicamente consiste en que los objetos sepan c√≥mo clonarse a s√≠ mismos

### Motivaci√≥n

- Tenemos que crear un framework para editores gr√°ficos
- Un usuario podr√≠a construir con √©l un editor de partituras musicales
- Supongamos que el framework provee una clase abstracta `Graphic` para los elementos gr√°ficos
- El framework tambi√©n proporciona una clase `GraphicTool` para los elementos de la paleta que permiten crear s√≠mbolos gr√°ficos
- ¬øC√≥mo podr√≠amos parametrizar `GraphicTool` con el tipo de objeto a crear, aplicando la composici√≥n de objetos?
	- Haciendo que cada instancia de ella reciba en el constructor un objeto representando el tipo de figura a crear
	- Y que cada figura sepa c√≥mo clonarse a s√≠ misma

![](img/Pasted%20image%2020240604121940.png)

### Aplicabilidad

√ösese el patr√≥n Prototype cuando un sistema deba ser independiente de c√≥mo se crean, se componen y se representan sus productos, y adem√°s se da alguna de estas circunstancias:
- Las clases a instanciar son definidas en tiempo de ejecuci√≥n
- Para evitar construir una jerarqu√≠a paralela de factor√≠as de productos
- Cuando las instancias de una clase puedan tener s√≥lo unos pocos posibles estados, y pueda resultar m√°s conveniente crear los objetos correspondientes como prototipos y clonarlos, en vez de instanciar manualmente la clase, cada vez con el estado necesario

### Estructura

![](img/Pasted%20image%2020240604122237.png)

![](img/Pasted%20image%2020240604122507.png)

### Participantes

- **Prototipo** (Prototype, Graphic)
	- Declara la interfaz (normalmente una √∫nica operaci√≥n para clonarse)
- **PrototipoConcreto** (ConcretePrototype, Staff, WholeNote, HalfNote)
	- Implementa la operaci√≥n de clonaci√≥n
- **Cliente** (Client, GraphicTool)
	- Crea un nuevo objeto dici√©ndole al prototipo que se clone

### Colaboraciones

- Un cliente le pide al prototipo que se clone

### Consecuencias

- Como el patr√≥n *Abstract Factory*, oculta las clases concretas de producto al cliente
- Adem√°s permite:
	- A√±adir y eliminar productos din√°micamente (en tiempo de ejecuci√≥n)
	- Especificar nuevos objetos modificando valores de sus propiedades
		- Mediante composici√≥n de objetos
	- Especificar nuevos objetos variando su estructura
		- A partir de partes y subpartes
		- Podemos guardar esas estructuras complejas para crearlas una y otra vez
		- Entrar√° el juego el patr√≥n *Composite*
	- Reduce las subclases
		- A diferencia del *Factory Method*
- **Inconvenientes**:
	- La implementaci√≥n de la operaci√≥n de clonaci√≥n puede no ser f√°cil

### Implementaci√≥n

- Es especialmente √∫til en lenguajes como Java y C++, donde las clases no son objetos
- Hay lenguajes que lo incorporan de serie
- Cuestiones a tener en cuenta:
	- Usar un gestor o registro de prototipos
	- Implementaci√≥n de la operaci√≥n de clonaci√≥n
		- ¬øCopia profunda o superficial?
	- Inicializaci√≥n de los prototipos

### Posibles usos

- Plantillas de Word

## Prototype vs Abstract Factory vs Factory Method

- El objeto f√°brica de *Abstract Factory* produce objetos de varias clases, mientras que el Prototype hace que el objeto f√°brica construya un producto copiando un objeto protot√≠pico. En este caso, el objeto f√°brica y el prototipo son el mismo objeto, ya que el prototipo es el responsable de devolver el producto.
- El *Factory Method* puede requerir crear una nueva subclase simplemente para cambiar la clase del producto (dichos cambios pueden tener lugar en cascada). Mientras que el Prototype hace que el objeto f√°brica construya un producto copiando un objeto protot√≠pico. En este caso, el objeto f√°brica y el prototipo son el mismo objeto, ya que el prototipo es el responsable de devolver el producto.

>[!Note]
>*Esto est√° sacado del GoF*

