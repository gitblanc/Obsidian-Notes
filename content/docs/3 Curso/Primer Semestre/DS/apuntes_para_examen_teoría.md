---
title: Apuntes para Examen Teor√≠a DS üë£
---
>[!Tip]
>Si quieres ir directamente al grano, te recomiendo que hagas `Ctrl + F` y busques ==Pregunta t√≠pica de examen==. As√≠ s√≥lo te estudias "lo m√°s relevante"

# Tema 1. Introducci√≥n al dise√±o OO

## Dise√±o vs An√°lisis

- **An√°lisis**: pone √©nfasis en una investigaci√≥n del problema y los requisitos, en vez de en la coluci√≥n
- **Dise√±o**:  pone √©nfasis en una soluci√≥n conceptual que satisface los requisitos
	- Es importante un buen dise√±o por el **cambio**

## Representaci√≥n en UML

![](img/Pasted%20image%2020240602110840.png)

## Resultado del dise√±o OO

Se obtiene como resultado:
- Un sistema de objetos que satisfacen los requisitos
- Una descripci√≥n del comportamiento p√∫blico de esos objetos
- C√≥mo se comunican esos objetos entre s√≠

![](img/Pasted%20image%2020240602111004.png)

## Orientaci√≥n a objetos

- El dise√±o orientado a objetos construye las aplicaciones mediante una estructura de objetos que colaboran entre s√≠
- Cada objeto realiza unas operaciones que lo caracterizan
	- No importa c√≥mo las realice, sino cu√°les realiza
	- La implementaci√≥n de esas operaciones son los **m√©todos**
- Un **objeto** lleva a cabo una **operaci√≥n** cuando recibe una petici√≥n (o mensaje) de un cliente
	- Un mensaje es la √∫nica forma de decirle a un objeto que ejecute una operaci√≥n
	- Las operaciones son el √∫nico modo de cambiar el estado interno del objeto
	- Por ese motivo, se dice que el estado interno del objeto est√° **encapsulado**
		- No se puede acceder a √©l directamente, y su representaci√≥n es invisible desde el exterior del objeto

## Mensajes

- Una aplicaci√≥n realiza sus operaciones mediante la combinaci√≥n de las operaciones de uno o m√°s objetos
- Cuando se desea que un objeto realice una operaci√≥n se le env√≠a un mensaje
- Para realizarla, podr√° enviar a su vez mensajes a otros objetos

![](img/Pasted%20image%2020240602111618.png)

## Interfaz de un objeto

- **Signatura de la operaci√≥n**: es lo que especifica cada operaci√≥n declarada por un objeto (su nombre, los objetos que recibe como par√°metros y el tipo de valor devuelto por la operaci√≥n)
- **Interfaz de un objeto**: es el conjunto de todas las signaturas (p√∫blicas) definidas por √©l
	- Es decir, todas las peticiones que pueden hac√©rsele
- **Tipo**: es un nombre usado para denotar una determinada interfaz
	- Decimos que un objeto es del tipo `Window` si puede aceptar todas las peticiones para las operaciones definidas en la interfaz `Window`
	- Un **objeto puede tener muchos tipos**, as√≠ como objetos muy diferentes pueden compartir un mismo tipo
	- Un tipo es **subtipo** de otro si su interfaz contiene la interfaz de su **supertipo**

## Enlace din√°mico

- **Enlace din√°mico**: asociaci√≥n en tiempo de ejecuci√≥n que tiene lugar entre la petici√≥n a un objeto y una de sus operaciones. Permite:
	- Escribir programas que esperen un objeto con una interfaz determinada, sabiendo que cualquier objeto que tenga esa interfaz aceptar√° la petici√≥n
	- Sustituir en tiempo de ejecuci√≥n un objeto por otro con la misma interfaz (**polimorfismo**)

## Polimorfismo

- **Polimorfismo**: es la capacidad de dos o m√°s tipos de objetos de responder al mismo mensaje, cada uno a su manera
	- Un objeto no necesita saber a qui√©n est√° enviando el mensaje

>[!Example]
>El polimorfismo nos permite tener una lista de figuras y poder dibujarlas todas sin conocerlas (sin saber de qu√© tipo concreto es cada una):

![](img/Pasted%20image%2020240602112614.png)

## Clase

- **Clase**: es una de las formas de crear tipos en Java

### Definici√≥n de las clases

1. Determinar el nombre que se quiere dar al conjunto de operaciones
2. Elecci√≥n de las operaciones que realizar√°n los objetos del nuevo tipo (qu√© mensajes podr√°n recibir)
	- Las operaciones pueden ser de dos tipos:
		- **Acciones**: ordenan al objeto hacer algo
		- **Consultas**: piden al objeto alguna informaci√≥n
3. Implementaci√≥n de los mensajes

## Creaci√≥n de objetos

- Los objetos se crean instanciando clases
- Un objeto se dice que es una instancia de una clase

### S√≠ntomas de programaci√≥n estructurada encubierta

==Pregunta t√≠pica de examen==

- M√©todos largos
	- M√°s de 10 l√≠neas (no se est√° delegando)
- Abundancia de llamadas a m√©todos del mismo objeto
- Preguntarse c√≥mo se calcula un factorial en un lenguaje OO
	- Lo importante es el qui√©n, no el c√≥mo
- T√≠pica clase de `Utilidades`
	- No se encuentra un qui√©n: no se han asignado bien las responsabilidades

## Atributos

- **Atributos**: almacenan el estado interno del objeto, es decir, forma de guardar la informaci√≥n para su posterior uso por otros mensajes

![](img/Pasted%20image%2020240602113615.png)

>[!Tip]
>- No se debe empezar el dise√±o de una clase por sus atributos, ya que si la clase cambia, √©stos tambi√©n lo har√°n.
>- No hay que plantear la implementaci√≥n como formas de modificar dichos atributos.
>- En vez de eso, se han de plantear las acciones que debe realizar el objeto
>- Nunca poner como atributo lo que deber√≠a ser una variable local de un m√©todo

## Par√°metros

- **Par√°metros**: son la forma de enviar informaci√≥n junto con el mensaje (en caso de que un objeto necesite informaci√≥n adicional para llevar a cabo una operaci√≥n)

## Opciones y operandos

- **Opci√≥n**: representa una forma de operar con los operandos
- **Operando**: es un objeto que el m√©todo necesita para operar

>[!Tip]
>¬øC√≥mo diferenciarlos?
>- Los **operandos** permanecen estables mientras que las opciones pueden variar a medida que la clase evolucione
>- Un par√°metro es una **opci√≥n** si se puede encontrar un valor predeterminado adecuado

![](img/Pasted%20image%2020240602114424.png)

`document` es un operando y el resto son opciones (ya que pueden tener un valor predeterminado: A4, false, 1920x1080)

![](img/Pasted%20image%2020240602114554.png)

### Ventajas de separarlos

- Es m√°s f√°cil de invocar al mensaje
- A medida que la clase evolucione se podr√°n a√±adir m√°s opciones, pero los clientes de la clase no se ver√°n afectados

![](img/Pasted%20image%2020240602114753.png)

![](img/Pasted%20image%2020240602114809.png)

![](img/Pasted%20image%2020240602114837.png)

>[!Note]
>- En la primera versi√≥n, el cliente deb√≠a conocer todas las opciones permitidas por la impresora ***aunque no las utilizase***
>- En la segunda forma al cliente se le pasa la impresora en el estado adecuado para que √©ste la utilice como se desea

*Mezclar estos conceptos significa no aplicar a√∫n el concepto de **estado de un objeto***

## Estado de un objeto

- **Estado de un objeto**: es la combinaci√≥n de los valores de los atributos de un objeto
	- Los valores de los atributos determinar√°n el comportamiento del objeto ante los distintos mensajes que reciba
	- El estado de un objeto determina la respuesta del objeto ante cada uno de los mensajes:
		- Determina qu√© mensajes no son permitidos
		- Determina el modo de actuar de los permitidos

- Guardar el estado de un objeto supone guardar la suficiente informaci√≥n para que al recuperarla se obtengan exactamente las mismas respuestas ante la misma secuencia de mensajes

## Encapsulaci√≥n

- Normalmente no se debe dar acceso a los datos internos de un objeto

![](img/Pasted%20image%2020240602115449.png)

### Ventajas

- Permite controlar las modificaciones del atributo

![](img/Pasted%20image%2020240602115553.png)

- Ocultar los atributos permite modificar la implementaci√≥n sin afectar a los clientes

![](img/Pasted%20image%2020240602115636.png)

## Criterio de independencia

- **Criterio de independencia**: cuanto menos se sepa de la implementaci√≥n de un objeto menos afectar√°n sus cambios
	- Lo √∫nico importante de un objeto son los **mensajes** que puede recibir

## Estado concreto y estado abstracto

>[!Example]
>- Si en una clase `Temperatura` al pedir los datos en Celsius est√°n en Fahrenheit... ¬øse cambia el estado del objeto?
>	- No, porque no cambia sus respuestas, es decir, no cambia su comportamiento

- **Estado concreto**: se define en funci√≥n de los atributos (podr√≠a variar en dependiendo de la implementaci√≥n)
- **Estado abstracto**: se define en funci√≥n de las respuestas a los mensajes

>[!Note]
>Cuando hablamos de estado siempre nos referimos al **estado abstracto**

## Dise√±o de clases

- Lo dif√≠cil es averiguar qu√© clases poner y con qu√© mensajes cada una

### Lo que no funciona

- Basarse en objetos reales
- No sirve extraer nombres y verbos del lenguaje natural
	- El **ascensor** tiene una **puerta** que se *abre* y se *cierra*
- Adem√°s puede expresarse de varias maneras
- Intentar sacar clases sin saber todav√≠a qu√© tienen que hacer
- Centrarse en las tareas que realizar (el *qu√©*) y no separarlo jam√°s del *qui√©n* (sino ser√≠a programaci√≥n estructurada)

### Gu√≠a pr√°ctica

1. Elegir una tarea a realizar (el *qu√©*)
	- Decidir qu√© tipo de objeto lo har√°
	- ¬øPuede hacerla alguna de las clases que ya tenemos?
		- Si es as√≠, a√±adir la nueva operaci√≥n a dicha clase
2. Decidida la clase y la responsabilidad, tocan los mensajes
	- Dividir la responsabilidad en operaciones at√≥micas (para que se puedan combinar)
	- Par√°metros con informaci√≥n imprescindible (el resto **opciones**)
	- Sacar partido de que los objetos "recuerdan" los que se les ha mandado (crear objetos inteligentes)
3. Implementaci√≥n de las operaciones (los m√©todos)
	- Cualquiera que no tenga errores
	- No preocuparse por la eficiencia hasta el final

## Interfaces vs Clases abstractas

- **Interfaces**: permiten comunicar objetos que no se conocen

![](img/Pasted%20image%2020240602121247.png)

![](img/Pasted%20image%2020240602121318.png)

![](img/Pasted%20image%2020240602121341.png)

![](img/Pasted%20image%2020240602121458.png)

La revisi√≥n del contrato se har√° de manera est√°tica:

![](img/Pasted%20image%2020240602121537.png)

### Tipos de herencia

- **De interfaz**: declaramos el compromiso de implementar unos m√©todos (*subtipos*)
- **De implementaci√≥n**: creaci√≥n de una clase a partir de la implementaci√≥n de otra (*reutilizaci√≥n de c√≥digo*)

>[!Tip]
>**Criterio de dise√±o**
>- Cuando un objeto deba delegar ciertas operaciones en otro deber√° exig√≠rselas mediante una interfaz
>	- Importan los mensajes que acepta el objeto, no de qui√©n ha obtenido su implementaci√≥n

## Reutilizaci√≥n con interfaces

![](img/Pasted%20image%2020240602121916.png)

![](img/Pasted%20image%2020240602121932.png)

Soluci√≥n:

![](img/Pasted%20image%2020240602121948.png)

## Clases abstractas

- Usos:
	- Factorizar c√≥digo propio
	- Facilitar la extensi√≥n

### Ejemplo de factorizar c√≥digo propio

![](img/Pasted%20image%2020240602122909.png)

![](img/Pasted%20image%2020240602122924.png)

- El jubilado y el catedr√°tico hacen pr√°cticamente lo mismo. ¬øC√≥mo lo evitamos?
	- Mediante clases abstractas

![](img/Pasted%20image%2020240602123025.png)

### Ejemplo de facilitar la extensi√≥n

![](img/Pasted%20image%2020240602123233.png)

![](img/Pasted%20image%2020240602123330.png)

Se puede aprovechar c√≥digo ya implementado:

![](img/Pasted%20image%2020240602123446.png)

- Copiando y pegando c√≥digo ser√≠a:

![](img/Pasted%20image%2020240602123522.png)

Aqu√≠ es donde nacen los m√©todos abstractos:

![](img/Pasted%20image%2020240602123555.png)

## Jerarqu√≠as de interfaces

![](img/Pasted%20image%2020240602123758.png)

En Orientado a Objetos:
- Se extraen las entidades
- Se buscan las relaciones entre ellos (herencia, agregaci√≥n y asociaci√≥n)
	- "Es un", "tiene un", "parece casi como un"...

>[!Tip]
>Nunca debe surgir una jerarqu√≠a como manera de clasificaci√≥n
>- Hay que comprobar si toda interfaz tiene al menos un cliente que la use

![](img/Pasted%20image%2020240602124036.png)

>[!Tip]
>**Sin necesidad no hay interfaz**


## Jerarqu√≠as de clases abstractas

![](img/Pasted%20image%2020240602124249.png)

![](img/Pasted%20image%2020240602124329.png)

![](img/Pasted%20image%2020240602124346.png)

>[!Note]
>Una jerarqu√≠a de implementaci√≥n (de clases abstractas) no es esencial que sea estable
>- El cliente s√≥lo conoce la interfaz
>- No sabe si debajo de esa interfaz hay una jerarqu√≠a de clases abstractas para ahorrar c√≥digo o clases que implementan directamente la interfaz (no trata directamente con ellas)
>- No le afectan las reorganizaciones que haya de sus implementaciones
>
>Las jerarqu√≠as de implementaci√≥n son para compartir c√≥digo com√∫n y puede reestructurarse cuantas veces se necesite
>- Hay que reorganizar el √°rbol en funci√≥n de las necesidades actuales


>[!Example]
>Veamos qu√© ocurrir√≠a si tuvi√©semos dos o m√°s interfaces, cada una con su correspondiente implementaci√≥n base que quisi√©ramos aprovechar, en un lenguaje como Java que no tiene herencia m√∫ltiple.

![](img/Pasted%20image%2020240602124903.png)

Posible soluci√≥n:

![](img/Pasted%20image%2020240602124920.png)

![](img/Pasted%20image%2020240602124935.png)

## Tabla Interfaz vs Clase abstracta

==Pregunta t√≠pica de examen==

|                                     | Interfaz                                                                              | Clase abstracta                                                                    |
| ----------------------------------- | ------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |
| **Situaci√≥n en la que se originan** | Extracci√≥n de responsabilidades                                                       | Facilitar nuevas implementaciones. No repetir c√≥digo                               |
| **Creador**                         | Analista/Dise√±ador                                                                    | Programador                                                                        |
| **¬øRa√≠z?**                          | S√≠                                                                                    | No                                                                                 |
| **Importancia**                     | Fundamental: es el enlace din√°mico, lo que nos permite eliminar la l√≥gica condicional | Comodidad (es un mero cortar y pegar)                                              |
| **Operaciones**                     | A√±aden a las de sus ancestros                                                         | Implementan las de sus ancestros. A√±aden operaciones de implementaciones parciales |
| **Impacto de los cambios**          | Alto; es un contrato que afecta a varios programadores                                | Bajo; la interfaz hace de cortafuegos                                              |

![](img/Pasted%20image%2020240602125450.png)

## ¬øQu√© quiere decir que las interfaces hacen de cortafuegos?

==Pregunta t√≠pica de examen==

En un buen dise√±o software, en¬†**la ra√≠z**¬†de una jerarqu√≠a siempre deber√≠a situarse una interfaz ya que representan un contrato como resultado de las necesidades del cliente. A √©ste no le interesa el c√≥mo (lo hace), sino el qu√© (deben poder hacer los objetos que implementan dicha interfaz).

Si no lo hici√©ramos as√≠ y us√°semos una clase base (abstracta o no) como ra√≠z de la jerarqu√≠a, nos estar√≠amos atando a una determinada funcionalidad que ante un cambio en los requisitos lo que era com√∫n en las subclases ya no lo sea.

En definitiva, con una **interfaz** el cliente no se inmuta si cambia el c√≥mo, mientras que con una **clase base**, se ver√≠a afectado ante un cambio.

## S√≠ntomas de un dise√±o pobre

==Pregunta t√≠pica de examen==

- **Rigidez**: *es dif√≠cil de cambiar* 
	- Representa una resistencia al cambio
	- Un dise√±o es r√≠gido si un simple cambio causa una sucesi√≥n de cambios en cascada en otros m√≥dulos dependientes
- **Fragilidad**: *es f√°cil que falle*
	- Un programa es fr√°gil si un cambio en una parte del sistema causa un fallo en otras partes no relacionadas conceptualmente
	- Estos son los m√≥dulos que continuamente est√°n siendo reparados
- **Inmovilidad**: *es dif√≠cil de reutilizar*
	- Es dif√≠cil separar el c√≥digo en componentes que puedan ser reutilizados en otros sistemas (el esfuerzo de separarlo es demasiado grande)
- **Viscosidad**: *es dif√≠cil hacer lo correcto*
	- Se refiere a que es m√°s f√°cil hacer las cosas mal en lugar de bien
	- Un proyecto viscoso es aqu√©l en el que resulta dif√≠cil preservar el dise√±o original
	- **Viscosidad del software**: si hacer los cambios respetando el dise√±o original es m√°s costoso que hacerlos mal
	- **Viscosidad del entorno de desarrollo**: si es lento e ineficiente (tiempo de compilaci√≥n elevado...). Condiciona las decisiones de los desarrolladores
- **Complejidad innecesaria**: *sobredise√±o*
	- Si el dise√±o contiene elementos que no resultan √∫tiles (demasiada anticipaci√≥n a los cambios en los requisitos)
	- Mucha de esa funcionalidad no se utilizar√°
	- Hace el software complejo y dif√≠cil de comprender
- **Repetici√≥n innecesaria**: *"copiar y pegar"*
	- Duplicaci√≥n de c√≥digo
	- El coste del cambio es cada vez mayor y es propenso a errores
- **Opacidad**: *es complejo averiguar su intenci√≥n*
	- Dificultad de comprender un m√≥dulo o un programa
	- Debemos hacer un esfuerzo constante por mantener siempre el c√≥digo tan claro y expresivo como sea posible
		- Que revele su intenci√≥n
		- Debemos ponernos en el papel de quien va a leer nuestro c√≥digo

## Principios SOLID

==Pregunta t√≠pica de examen==

- **SRP** (*Single Responsibility Principle*, Principio de Responsabilidad √önica): Una clase deber√≠a tener un √∫nico motivo para cambiar
	- Definimos responsabilidad como una raz√≥n para el cambio
	- Si podemos pensar en m√°s de un motivo por el que la clase deber√≠a cambiar, dicha clase tiene m√°s de una responsabilidad

>[!Example]
>![](img/Pasted%20image%2020240602131818.png)
>
>![](img/Pasted%20image%2020240602131852.png)
>
>Este dise√±o viola el principio SRP, pues la clase `Rectangle` tiene dos responsabilidades

- **OCP** (*Open-Closed Principle*, Principio de abierto-cerrado): las clases deber√≠an estar abiertas para la extensi√≥n, pero cerradas para la modificaci√≥n
	- La idea es que **los cambios se hagan a√±adiendo c√≥digo nuevo**, no modificando el anterior que funcionaba
	- Los principales mecanismos para lograr el principio de abierto-cerrado son la abstracci√≥n y el polimorfismo

>[!Example]
>![](img/Pasted%20image%2020240602132205.png)
>
>![](img/Pasted%20image%2020240602132237.png)

- **LSP** (*Liskov Substitution Principle*, Principio de sustituci√≥n de Liskov): los subtipos deben poder sustituir a sus tipos base
	- Los objetos de un programa deber√≠an ser reemplazables por instancias de sus subtipos sin alterar el correcto funcionamiento de un programa
	- Debemos asegurarnos de que las clases derivadas extiendan la clase base sin alterar su comportamiento de manera que se viole el contrato

>[!Example]
>![](img/Pasted%20image%2020240602132538.png)
>
>![](img/Pasted%20image%2020240602132558.png)

- **DIP** (*Dependency Inversion Principle*, Principio de inversi√≥n de dependencias):
	- Los m√≥dulos de alto nivel no deben depender de los de bajo nivel; ambos deben depender de las abstracciones
	- Las abstracciones no deben depender de los detalles, sino √©stos de las abstracciones
	- Se le conoce como el *Principio de Hollywood*
	- Simplificado: hay que depender de abstracciones, no de implementaciones concretas, es decir, programar para una interfaz, no para una implementaci√≥n

>[!Example]
>![](img/Pasted%20image%2020240602132813.png)
>

- **ISP** (*Interface Segregation Principle*, Principio de segregaci√≥n de interfaces):
	- Sugiere que los clientes no deber√≠an tratar con la clase original, sino s√≥lo con la interfaz correspondiente
	- Es mejor muchas interfaces espec√≠ficas para cada cliente que una sola interfaz de prop√≥sito general
	- Dicho de otra forma: los clientes no deber√≠an depender de los m√©todos que no usan

>[!Example]
>![](img/Pasted%20image%2020240602133216.png)
>
>![](img/Pasted%20image%2020240602133233.png)
>
>![](img/Pasted%20image%2020240602133250.png)
>
>![](img/Pasted%20image%2020240602133309.png)
>
>![](img/Pasted%20image%2020240602133327.png)
>
>![](img/Pasted%20image%2020240602133346.png)
>
>![](img/Pasted%20image%2020240602133409.png)

## Patrones GRASP

==Pregunta t√≠pica de examen==

- Son una serie de principios generales para asignar responsabilidades
- Mejor el t√©rmino Principios que Patrones, ya que no son soluciones a problemas concretos de dise√±o, sino m√°s bien principios que suelen ser aplicables siempre

- **GRASP 1** (*Experto en informaci√≥n*): asignar una responsabilidad al experto (la clase que tiene la informaci√≥n necesaria para llevarla a cabo)

>[!Example]
>![](img/Pasted%20image%2020240602134052.png)
>
>![](img/Pasted%20image%2020240602134128.png)
>
>![](img/Pasted%20image%2020240602134206.png)
>
>![](img/Pasted%20image%2020240602134238.png)
>
>![](img/Pasted%20image%2020240602134256.png)
>
>- **Contraindicaciones**:
>	- La clase `Sale` ahora deber√° contener la l√≥gica relacionada con la gesti√≥n de la base de datos
>		- Disminuye su cohesi√≥n, pues tiene una nueva responsabilidad
>		- Est√° acoplada, pues depende de servicios de otro subsistema
>		- Duplicaci√≥n de c√≥digo, pues es probable que la l√≥gica de acceso a datos est√© repetida
>- **Ventajas**:
>	- Se mantiene el encapsulamiento de la informaci√≥n (y hay un bajo acoplamiento)
>	- Se distribuye el comportamiento entre las clases que contienen la informaci√≥n requerida (alta cohesi√≥n)

- **GRASP 2** (*Creador*): ¬øQui√©n deber√≠a ser el responsable de la creaci√≥n de una nueva "instancia" de una clase?. Asignar a las clase B la responsabilidad de crear una instancia de la clase A si cumple alguna de las condiciones siguientes:
	- B agrega objetos de A
	- B contiene objetos de A
	- B registra objetos de A
	- B utiliza m√°s estrechamente objetos de A
	- B tiene los datos de inicializaci√≥n de un objeto de A

>[!Example]
>![](img/Pasted%20image%2020240602134943.png)
>
>- Contraindicaciones:
>	- A veces la creaci√≥n de objetos requiere una cierta complejidad
>		- En esos casos es conveniente delegar la creaci√≥n a una clase de fabricaci√≥n auxiliar
>	- *Mucho ojo con las factor√≠as*

- **GRASP 3** (*Bajo acoplamiento*): 
	- ¬øC√≥mo lograr que haya pocas dependencias, que los cambios tengan un bajo impacto e incrementar la reutilizaci√≥n?
		- Asignar una responsabilidad de manera que el acoplamiento permanezca bajo
	- **Acoplamiento**: medida de la fuerza con que un elemento est√° conectado a otros
		- Si un elemento tiene un bajo acoplamiento no depende de demasiados otros elementos
		- Si una clase presenta un fuerte acoplamiento con otras, cambios en esas clases obligan a hacer cambios en ella

>[!Example]
>![](img/Pasted%20image%2020240602140327.png)
>
>Soluci√≥n alternativa:
>
>![](img/Pasted%20image%2020240602140411.png)
>
>![](img/Pasted%20image%2020240602140435.png)
>
>Ventajas del bajo acoplamiento:
>- No afectan los cambios en otros componentes
>- F√°cil de entender de manera aislada
>- Favorece la reutilizaci√≥n

- **GRASP 4** (*Alta cohesi√≥n*):
	- ¬øC√≥mo mantener la complejidad manejable?
		- Asignar una responsabilidad de manera que la cohesi√≥n permanezca alta
	- **Cohesi√≥n**: es una medida de la fuerza con que se relacionan las responsabilidades de un elemento
	- Una clase con baja cohesi√≥n hace muchas cosas no relacionadas. Presentan los siguientes problemas:
		- Dif√≠ciles de entender
		- Dif√≠ciles de reutilizar
		- Dif√≠ciles de mantener
		- Delicadas, constantemente afectadas por los cambios

>[!Example]
>![](img/Pasted%20image%2020240602140913.png)
>
>![](img/Pasted%20image%2020240602140931.png)
>
>![](img/Pasted%20image%2020240602140952.png)
>
>![](img/Pasted%20image%2020240602141018.png)

- **GRASP 5** (*Controlador*): 
	- ¬øQui√©n debe ser responsable de gestionar un evento de entrada al sistema?
		- Asignar la responsabilidad de recibir o manejar un evento a una clase que representa las siguientes opciones:
			- Representa el sistema global, un dispositivo o un subsistema
			- Representa un escenario de caso de uso en el que tiene lugar el evento

>[!Example]
>![](img/Pasted%20image%2020240602142456.png)
>
>![](img/Pasted%20image%2020240602142523.png)
>
>![](img/Pasted%20image%2020240602142541.png)

- **GRASP 6** (*Polimorfismo*): 
	- ¬øC√≥mo manejar las alternativas basadas en el tipo? ¬øC√≥mo crear componentes software conectables?
		- Cuando las alternativas o comportamientos relacionados var√≠an seg√∫n el tipo de objeto, se asignar√° la responsabilidad a los tipos para los que var√≠a el comportamiento, empleando operaciones polim√≥rficas
		- Es decir, hay que intentar huir de la l√≥gica condicional con respecto al tipo (`if`, `switch`, `instanceof`...)

>[!Example]
>![](img/Pasted%20image%2020240602142850.png)
>
>![](img/Pasted%20image%2020240602142909.png)
>
>![](img/Pasted%20image%2020240602142930.png)

- **GRASP 7** (*Fabricaci√≥n pura*):
	- ¬øQu√© objetos deber√≠an tener la responsabilidad cuando no se quiere violar los principios de alta cohesi√≥n y bajo acoplamiento pero, sin embargo, las soluciones que ofrece el experto no son adecuadas?
		- Se asignar√° un conjunto de responsabilidades altamente cohesivo a una clase artificial, de conveniencia, que no representa un concepto del dominio del problema, sino que se ha inventado para permitir esa alta cohesi√≥n, bajo acoplamiento y la reutilizaci√≥n de c√≥digo.

>[!Example]
>![](img/Pasted%20image%2020240602143208.png)

- **GRASP 8** (*Indirecci√≥n*): 
	- ¬øD√≥nde asignar una responsabilidad, para evitar el acoplamiento directo entre dos o m√°s elementos?
		- Se asignar√° la responsabilidad a un objeto intermedio que medie entre otros componentes o servicios de manera que no se acoplen directamente
- **GRASP 9** (*Variaciones protegidas*): 
	- ¬øC√≥mo dise√±ar objetos, subsistemas y sistemas de manera que las variaciones o inestabilidades en estos elementos no tengan un impacto no deseable en otros elementos?
		- Identifique los puntos de variaciones previstas o de inestabilidad; asigne responsabilidades para crear una interfaz estable alrededor de ellos.
		- Es decir, identificar aquellos aspectos que var√≠an y separarlos de lo que tiende a permanecer igual (encapsular y aislar el concepto que no var√≠a)
	- Mecanismos de Variaciones protegidas:
		- Principio de abierto-cerrado
		- Principio de sustituci√≥n de Liskov
		- Principio de inversi√≥n de dependencias
		- Principio de segregaci√≥n de interfaces
## Dise√±o modular

- **Modularidad**: es la propiedad de un sistema que se ha descompuesto en un conjunto de m√≥dulos cohesivos y d√©bilmente acoplados
	- La modularidad se alcanza dise√±ando cada m√©todo con un √∫nico y claro objetivo, y agrupando un conjunto de aspectos relacionados en una clase

## Acoplamiento, cohesi√≥n y el cambio

==Pregunta t√≠pica de examen==

### Acoplamiento

![](img/Pasted%20image%2020240602141430.png)

### Acoplamiento y cohesi√≥n (Beck)

- **Cohesi√≥n**: mide el grado de conectividad entre las funciones y elementos de un mismo m√≥dulo
	- Beck dice lo siguiente:
		- Un elemento es cohesivo en la medida en que el elemento entero cambia cuando el sistema necesita hacer un cambio en una funcionalidad determinada
		- Y lo relaciona tambi√©n con el tama√±o: un elemento puede perder cohesi√≥n si es demasiado grande o demasiado peque√±o

![](img/Pasted%20image%2020240602141535.png)

![](img/Pasted%20image%2020240602141711.png)

![](img/Pasted%20image%2020240602141723.png)

### Suficiencia, completitud y ser primitivo

- **Suficiente**: el componente representa suficientes caracter√≠sticas de una abstracci√≥n como para permitir una abstracci√≥n significativa con el componente
	- *Si estamos dise√±ando una clase Conjunto, est√° muy bien tener una operaci√≥n para eliminar un elemento dado, pero servir√° de muy poco si no tenemos otra para a√±adir elementos al conjunto.*
- **Completo**: la interfaz del componente representa todas las caracter√≠sticas de la abstracci√≥n
	- *Diferente de la suficiencia: all√≠ √≠bamos a m√≠nimos; la completitud hace referencia a que ofrezca una interfaz lo suficientemente general como para que pueda ser utilizado por cualquier cliente. Es una cualidad subjetiva (y peligrosa).*
- **Primitivo**: si todas las operaciones que realiza un componente pueden implementarse f√°cil y eficientemente, necesitando acceder a la representaci√≥n interna del componente
	- *Matiza lo anterior: la operaci√≥n ¬´a√±adir¬ª del conjunto es primitiva; una para a√±adir varios elementos a la vez no (puede lograrse con la anterior, sin requerir acceso a la representaci√≥n interna). De nuevo, es algo subjetivo.*

### Cohesi√≥n

![](img/Pasted%20image%2020240602142154.png)

## ¬øQu√© es un buen dise√±o?

==Pregunta t√≠pica de examen==

- Un sistema est√° bien dise√±ado si:
	- Es f√°cil de comprender
		- Si la responsabilidad se indica claramente (nombres adecuados, se usan patrones de dise√±o) 
	- Es f√°cil de cambiar
		- Hay que tener en cuenta que todo programa sufrir√° cambios, y el objetivo del dise√±o es facilitarlos. De esta forma, *dise√±ar para el cambio* significa:
			- S√≥lo hay que cambiar en un √∫nico sitio (o a√±adiendo c√≥digo nuevo -> Principio Abierto-Cerrado)
			- Es f√°cil determinar el lugar de dicho cambio
			- Debemos centrarnos en clases y m√©todos cohesivos (una √∫nica responsabilidad)

>[!Tip]
>¬°Hay que dise√±ar para el cambio!
>- Todo programa sufrir√° cambios
>- El objetivo es facilitarlos
>- Un cambio ser√° f√°cil de realizar si:
>	- S√≥lo hay que hacerlo en un √∫nico sitio
>	- Resulta f√°cil determinar dicho sitio

# Tema 2. Patrones de Dise√±o

## Herencia de clases vs Herencia de interfaces

- **Herencia de clases**: es un mecanismo para reutilizar c√≥digo
- **Herencia de interfaces**: describe cu√°ndo se puede utilizar un objeto en lugar de otro (subtipos)

>[!Tip]
>Hay que programar para una interfaz, no para una implementaci√≥n


## Herencia frente a composici√≥n

==Pregunta t√≠pica de examen==

- **Herencia de clases**: permite definir la implementaci√≥n de una clase en t√©rminos de la de otra
	- Se define est√°ticamente, en tiempo de compilaci√≥n
	- Es f√°cil de usar
	- La subclase es muy dependiente de la implementaci√≥n de la clase padre (hace muy dif√≠cil la reutilizaci√≥n en otros dominios)
- **Composici√≥n de objetos**: es una alternativa a la herencia, donde la nueva funcionalidad se obtiene ensamblando o componiendo nuevos objetos
	- Se define din√°micamente en tiempo de ejecuci√≥n a trav√©s de objetos que guardan referencias a otros objetos
	- A estos objetos s√≥lo se accede a trav√©s de sus interfaces
	- Se puede cambiar cualquier objeto por otro de su mismo tipo en tiempo de ejecuci√≥n
	- Ayuda a que la clase se centre en una √∫nica tarea

## Elementos de un patr√≥n

- **Contexto**: describe las situaciones en las que se da el problema
- **Problema**: descripci√≥n general que represente bien la esencia de √©ste
- **Soluci√≥n**: c√≥mo resolver el problema

## Categor√≠as de Patrones

- **Arquitect√≥nicos**: situados a un nivel de abstracci√≥n m√°s alto, describen la arquitectura, la estructura de un sistema en torno a subsistemas y las relaciones entre ellos (ej: Modelo Vista Controlador)
- **De dise√±o**: se sit√∫an en el nivel de abstracci√≥n medio, de dise√±o (independientes del lenguaje de programaci√≥n, ej: Observer)
- **Centrados en el c√≥digo**: o Modismos, que suelen ser espec√≠ficos de un lenguaje de programaci√≥n determinado.
	- Revelan su intenci√≥n

## Elementos de un patr√≥n

![](img/Pasted%20image%2020240602175226.png)

## Secciones de un patr√≥n de dise√±o

![](img/Pasted%20image%2020240602175311.png)

![](img/Pasted%20image%2020240602175325.png)

![](img/Pasted%20image%2020240602175338.png)
## Organizaci√≥n del cat√°logo de patrones

![](img/Pasted%20image%2020240602175419.png)

## Causas de redise√±o

>[!Note]
>Aqu√≠ incluyo cu√°ndo se debe usar cada patr√≥n

>[!Tip]
>**TIP 1**: *crear un objeto especificando expl√≠citamente su clase*
>
>Si se especifica el nombre de la clase en el c√≥digo al crear el objeto nos liga a una implementaci√≥n particular en vez de a una interfaz.
>
>Es mejor crear los objetos directamente.
>
>Se usan los patrones: *Abstract Factory*, *Factory Method* y *Prototype*


>[!Tip]
>**TIP 2**: *depender de operaciones concretas*
>
>Evitando llamar directamente a un m√©todo determinado en el c√≥digo se facilita cambiar la forma en que se responde a una petici√≥n
>
>Se usan los patrones: *Chain of Responsibility* y *Command*

>[!Tip]
>**TIP 3**: *dependencia de plataformas de hardware o software*
>
>Las interfaces de los sistemas operativos y las APIs de muchas aplicaciones son dependientes de la plataforma
>
>Hay que limitar dichas dependencias
>
>Se usan los patrones: *Abstract Factory* y *Bridge*

>[!Tip]
>**TIP 4**: *depender de implementaciones o representaciones de objetos*
>
>Los clientes que conocen c√≥mo se representa internamente c√≥mo se almacena, d√≥nde se localiza o c√≥mo se implementa tendr√°n que cambiar cuando cambie aqu√©l
>
>Se usan los patrones: *Abstract Factory*, *Bridge*, *Memento* y *Proxy*

>[!Tip]
>**TIP 5**: *dependencias de algoritmos*
>
>Los algoritmos que es probable que cambien a lo largo del tiempo (para optimizarlos o porque se sustituyan por otro distinto) deben estar aislados
>
>Se usan los patrones: *Builder*, *Iterator*, *Strategy*, *Template Method* y *Visitor*

>[!Tip]
>**TIP 6**: *fuerte acoplamiento*
>
>Es dif√≠cil reutilizar clases que est√°n fuertemente acopladas a otras
>
>Se usan los patrones: *Abstract Factory*, *Bridge*, *Chain of Responsibility*, *Command*, *Facade*, *Mediator* y *Observer*

>[!Tip]
>**TIP 7**: *extender funcionalidad mediante la herencia*
>
>Definir una subclase requiere un profundo conocimiento de la clase padre
>
>Se usan los patrones: *Bridge*, *Chain of Responsibility*, *Composite*, *Decorator*, *Observer* y *Strategy*

>[!Tip]
>**TIP 8**: *no se puede modificar las clases*
>
>A veces hay que modificar una clase de la que no disponemos del c√≥digo fuente o que requerir√≠a cambiar montones de subclases existentes
>
>Se usan los patrones: *Adapter*, *Decorator* y *Visitor*

# Diferencias entre patrones

==Pregunta t√≠pica de examen==

## Decorator vs Strategy

- *En cuanto a su prop√≥sito*, mientras que el **Strategy** permite cambiar parte del comportamiento interno de un objeto (el contexto), delegando en otro (la estrategia, que puede ser sustituido por otra estrategia), el **Decorator** a√±ade responsabilidades a uno o varios m√©todos de un objeto en tiempo de ejecuci√≥n, llevando a cabo tareas adicionales antes o despu√©s de llamar al m√©todo correspondiente del objeto que decora.
- *En cuanto a la forma de implementarlos*, un objeto sabe que internamente tiene una **estrategia** que lo completa sin la cual no puede funcionar, mientras que la presencia de un **decorador** es totalmente transparente al objeto que decora, envolvi√©ndolo desde fuera.

### Decorador vs lista de Estrategias

![](img/Pasted%20image%2020241212154129.png)

![](img/Pasted%20image%2020241212154143.png)

### Ejemplo: tickets (sistema de ficheros)

Con un **Decorator**:

![](img/Pasted%20image%2020241212154222.png)

![](img/Pasted%20image%2020241212154337.png)

Con una lista de Estrategias (**Strategy**):

![](img/Pasted%20image%2020241212154301.png)

![](img/Pasted%20image%2020241212154348.png)

## Decorator vs Composite

Un **Decorator** es como un **Composite** pero s√≥lo tiene un componente hijo. Adem√°s, el **Decorator** a√±ade responsabilidades adicionales al objeto envuelto, mientras que el **Composite** se limita a "recapitular" los resultados de sus hijos
## State vs Strategy

- **Strategy**: es seleccionada por un agente externo o por el contexto. Una estrategia tiende a tener un √∫nico m√©todo de "*inicio*" que llama a todos los dem√°s. Hay mucha cohesi√≥n entre los m√©todos de un Strategy
- **State**: un State generalmente selecciona el siguiente estado de su contexto. Un estado tiende a tener muchos m√©todos no relacionados, por lo que hay poca cohesi√≥n entre los m√©todos de un State.
	- Los m√©todos del State suelen llamarse igual y tener la misma signatura que las que ten√≠an dicho subconjunto de operaciones en el contexto

## Factory Method vs Abstract Factory

![](img/Pasted%20image%2020240603131608.png)

## Prototype vs Abstract Factory vs Factory Method

- El objeto f√°brica de **Abstract Factory** produce varios objetos de varias clases, mientras que el **Prototype** hace que el objeto f√°brica construya un producto copiando un objeto protot√≠pico. 
	- En este caso, el objeto f√°brica y el prototipo son el mismo objeto, ya que el prototipo es el responsable de devolver el producto
- El **Factory Method** puede requerir crear una nueva subclase simplemente para cambiar la clase del producto (dichos cambios pueden tener lugar en cascada), mientras que el **Prototype** hace que el objeto f√°brica construya un producto copiando un objeto protot√≠pico.
	- En este caso, el objeto f√°brica y el prototipo son el mismo objeto, ya que el prototipo es el responsable de devolver el producto